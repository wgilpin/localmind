"use strict";
/**
 * @module RagServiceIntegrationTests
 * @description Integration tests for the RagService,
 * mocking its dependencies to ensure end-to-end functionality.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const rag_1 = require("./rag");
const ollama_1 = require("./ollama");
const vectorStore_1 = require("./vectorStore");
const documentStore_1 = require("./documentStore");
// Mock the low-level services
jest.mock('./ollama');
jest.mock('./vectorStore');
jest.mock('./documentStore');
describe('RagService (Integration Tests)', () => {
    let ragService;
    let mockOllamaService;
    let mockVectorStoreService;
    let mockDocumentStoreService;
    beforeEach(() => {
        // Clear all mocks before each test
        jest.clearAllMocks();
        // Initialize RagService with mocked dependencies
        mockOllamaService = new ollama_1.OllamaService();
        mockVectorStoreService = new vectorStore_1.VectorStoreService('test-vector-store.faiss');
        mockDocumentStoreService = new documentStore_1.DocumentStoreService('test-document-store.json');
        ragService = new rag_1.RagService(mockOllamaService, mockVectorStoreService, mockDocumentStoreService);
    });
    describe('addDocument', () => {
        /**
         * @method addDocument
         * @description Tests the addDocument method of RagService.
         * Ensures it correctly calls add methods on document and vector stores,
         * and getEmbedding on Ollama service.
         */
        it('should correctly call add methods on document and vector stores and getEmbedding on Ollama service', () => __awaiter(void 0, void 0, void 0, function* () {
            // Define the document to be added (without ID, as it's generated by the service)
            const docToAdd = {
                content: 'test content',
                url: 'http://example.com/doc1',
                title: 'Test Document 1',
            };
            // Define the document that DocumentStoreService.add will return
            const addedDocWithId = Object.assign(Object.assign({}, docToAdd), { id: 'mock-doc-id', timestamp: Date.now() });
            const embedding = [0.1, 0.2, 0.3];
            mockOllamaService.getEmbedding.mockResolvedValue(embedding);
            mockDocumentStoreService.add.mockResolvedValue(addedDocWithId);
            // The add method in VectorStoreService is synchronous and returns void,
            // so we don't need to mockResolvedValue for it.
            // We'll just ensure it's called.
            yield ragService.addDocument(docToAdd);
            expect(mockOllamaService.getEmbedding).toHaveBeenCalledWith(docToAdd.content);
            // Expect that add was called with the document content, excluding the generated ID and timestamp
            expect(mockDocumentStoreService.add).toHaveBeenCalledWith(Object.assign(Object.assign({}, docToAdd), { timestamp: expect.any(Number) }));
            expect(mockVectorStoreService.add).toHaveBeenCalledWith([embedding]);
        }));
    });
    describe('search', () => {
        /**
         * @method search
         * @description Tests the search method of RagService,
         * ensuring the entire RAG pipeline logic is correct.
         */
        it('should correctly execute the RAG pipeline for a given query', () => __awaiter(void 0, void 0, void 0, function* () {
            const query = 'test query';
            const queryEmbedding = [0.4, 0.5, 0.6];
            // searchResults here represent the raw output from vectorStoreService.search
            // where 'id' is a conceptual placeholder for the FAISS index.
            const searchResults = [{
                    id: 0,
                    score: 0.9
                }, // Corresponds to document with ID '0'
                {
                    id: 1,
                    score: 0.8
                }, // Corresponds to document with ID '1'
            ];
            const documents = [{
                    id: '0',
                    content: 'content of doc1',
                    url: 'http://example.com/doc0',
                    title: 'Doc 0',
                    timestamp: Date.now()
                }, {
                    id: '1',
                    content: 'content of doc2',
                    url: 'http://example.com/doc1',
                    title: 'Doc 1',
                    timestamp: Date.now()
                },];
            const completion = 'generated completion';
            mockOllamaService.getEmbedding.mockResolvedValue(queryEmbedding);
            mockVectorStoreService.search.mockResolvedValue({
                I: searchResults.map(r => r.id),
                D: searchResults.map(r => r.score)
            });
            mockDocumentStoreService.get.mockImplementation((id) => __awaiter(void 0, void 0, void 0, function* () {
                if (id === '0')
                    return documents[0];
                if (id === '1')
                    return documents[1];
                return undefined;
            }));
            mockOllamaService.getCompletion.mockResolvedValue(completion);
            const result = yield ragService.search(query);
            expect(mockOllamaService.getEmbedding).toHaveBeenCalledWith(query);
            expect(mockVectorStoreService.search).toHaveBeenCalledWith(queryEmbedding, 5);
            expect(mockDocumentStoreService.get).toHaveBeenCalledTimes(2);
            expect(mockDocumentStoreService.get).toHaveBeenCalledWith('0');
            expect(mockDocumentStoreService.get).toHaveBeenCalledWith('1');
            const expectedPrompt = `
        You are a helpful AI assistant.
        Answer the following question based on the provided context:

        Question: ${query}

        Context:
        content of doc1

content of doc2
        `.trim().replace(/ {2,}/g, ' ');
            expect(mockOllamaService.getCompletion).toHaveBeenCalledWith(expectedPrompt);
            expect(result).toBe(completion);
        }));
        /**
         * @method search
         * @description Tests the search method when no relevant documents are found.
         */
        it('should return a default message if no relevant documents are found', () => __awaiter(void 0, void 0, void 0, function* () {
            const query = 'test query';
            const queryEmbedding = [0.4, 0.5, 0.6];
            mockOllamaService.getEmbedding.mockResolvedValue(queryEmbedding);
            mockVectorStoreService.search.mockResolvedValue({
                I: [],
                D: []
            });
            mockDocumentStoreService.get.mockResolvedValue(undefined); // All gets return undefined
            const result = yield ragService.search(query);
            expect(mockOllamaService.getEmbedding).toHaveBeenCalledWith(query);
            expect(mockVectorStoreService.search).toHaveBeenCalledWith(queryEmbedding, 5);
            expect(mockDocumentStoreService.get).not.toHaveBeenCalled(); // Should not call get if no results
            expect(mockOllamaService.getCompletion).not.toHaveBeenCalled(); // Should not call getCompletion
            expect(result).toBe('No relevant documents found.');
        }));
    });
});
