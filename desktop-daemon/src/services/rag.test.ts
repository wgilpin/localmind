/**
 * @module RagServiceIntegrationTests
 * @description Integration tests for the RagService,
 * mocking its dependencies to ensure end-to-end functionality.
 */

import {
  RagService
} from './rag';
import {
  OllamaService
} from './ollama';
import {
  VectorStoreService
} from './vectorStore';
import {
  DocumentStoreService
} from './documentStore';
import {
  Document
} from './documentStore';

// Mock the low-level services
jest.mock('./ollama');
jest.mock('./vectorStore');
jest.mock('./documentStore');

describe('RagService (Integration Tests)', () => {
  let ragService: RagService;
  let mockOllamaService: jest.Mocked < OllamaService > ;
  let mockVectorStoreService: jest.Mocked < VectorStoreService > ;
  let mockDocumentStoreService: jest.Mocked < DocumentStoreService > ;

  beforeEach(async () => {
    // Clear all mocks before each test
    jest.clearAllMocks();

    // Initialize RagService with mocked dependencies
    mockOllamaService = new OllamaService() as jest.Mocked < OllamaService > ;
    mockVectorStoreService = new VectorStoreService('test-vector-store.faiss') as jest.Mocked < VectorStoreService > ;
    mockDocumentStoreService = new DocumentStoreService('test-document-store.json') as jest.Mocked < DocumentStoreService > ;
    
    // Mock the getIds method to return an empty array by default
    mockDocumentStoreService.getIds.mockResolvedValue([]);


    ragService = await RagService.create(
      mockOllamaService,
      mockVectorStoreService,
      mockDocumentStoreService
    );
  });

  describe('addDocument', () => {
    /**
     * @method addDocument
     * @description Tests the addDocument method of RagService.
     * Ensures it correctly calls add methods on document and vector stores,
     * and getEmbedding on Ollama service.
     */
    it('should correctly call add methods on document and vector stores and getEmbedding on Ollama service', async () => {
      // Define the document to be added (without ID, as it's generated by the service)
      const docToAdd = {
        content: 'test content',
        url: 'http://example.com/doc1',
        title: 'Test Document 1',
      };
      // Define the document that DocumentStoreService.add will return
      const addedDocWithId: Document = { ...docToAdd,
        id: 'mock-doc-id',
        timestamp: Date.now()
      };
      const embedding = [0.1, 0.2, 0.3];

      mockOllamaService.getEmbedding.mockResolvedValue(embedding);
      mockDocumentStoreService.add.mockResolvedValue(addedDocWithId);
      // The add method in VectorStoreService is synchronous and returns void,
      // so we don't need to mockResolvedValue for it.
      // We'll just ensure it's called.

      await ragService.addDocument(docToAdd);

      expect(mockOllamaService.getEmbedding).toHaveBeenCalledWith(docToAdd.content);
      // Expect that add was called with the document content, excluding the generated ID and timestamp
      expect(mockDocumentStoreService.add).toHaveBeenCalledWith({
        ...docToAdd,
        timestamp: expect.any(Number)
      });
      expect(mockVectorStoreService.add).toHaveBeenCalledWith([embedding]);
    });
  });

  describe('search', () => {
    /**
     * @method search
     * @description Tests the search method of RagService,
     * ensuring the entire RAG pipeline logic is correct.
     */
    it('should correctly execute the RAG pipeline for a given query', async () => {
      const query = 'test query';
      const queryEmbedding = [0.4, 0.5, 0.6];
      const searchResults = [{
        id: 0,
        score: 0.9
      }, {
        id: 1,
        score: 0.8
      }, ];
      const documents: Document[] = [{
        id: '0',
        content: 'content of doc1',
        url: 'http://example.com/doc0',
        title: 'Doc 0',
        timestamp: Date.now()
      }, {
        id: '1',
        content: 'content of doc2',
        url: 'http://example.com/doc1',
        title: 'Doc 1',
        timestamp: Date.now()
      }, ];
      const completion = 'generated completion';

      mockOllamaService.getEmbedding.mockResolvedValue(queryEmbedding);
      mockVectorStoreService.search.mockResolvedValue({
        I: searchResults.map(r => r.id),
        D: searchResults.map(r => r.score)
      });
      mockDocumentStoreService.getMany.mockResolvedValue(documents);
      mockDocumentStoreService.getIds.mockResolvedValue(documents.map(doc => doc.id));
      mockOllamaService.getCompletion.mockResolvedValue(completion);
      
      // Re-initialize ragService with the correct mocks for this test case
      ragService = await RagService.create(
        mockOllamaService,
        mockVectorStoreService,
        mockDocumentStoreService
      );


      const result = await ragService.search(query);

      expect(mockOllamaService.getEmbedding).toHaveBeenCalledWith(query);
      expect(mockVectorStoreService.search).toHaveBeenCalledWith(queryEmbedding, 5);
      expect(mockDocumentStoreService.getMany).toHaveBeenCalledWith(['0', '1']);

      const expectedPrompt = `
        You are a helpful AI assistant.
        Answer the following question based on the provided context:

        Question: ${query}

        Context:
        content of doc1

content of doc2

        Instructions:
        Be concise.
        Do not refer to the context or the provided information .
        Constrain your answers very strongly to the provided material and if you do need to refer to you your built-in knowledge tell the user where you have done so.
        `.trim().replace(/ {2,}/g, ' ');

      expect(mockOllamaService.getCompletion).toHaveBeenCalledWith(expectedPrompt);
      expect(result).toBe(completion);
    });

    /**
     * @method search
     * @description Tests the search method when no relevant documents are found.
     */
    it('should return a default message if no relevant documents are found', async () => {
      const query = 'test query';
      const queryEmbedding = [0.4, 0.5, 0.6];

      mockOllamaService.getEmbedding.mockResolvedValue(queryEmbedding);
      mockVectorStoreService.search.mockResolvedValue({
        I: [],
        D: []
      });
      mockDocumentStoreService.getMany.mockResolvedValue([]);

      const result = await ragService.search(query);

      expect(mockOllamaService.getEmbedding).toHaveBeenCalledWith(query);
      expect(mockVectorStoreService.search).toHaveBeenCalledWith(queryEmbedding, 5);
      expect(mockDocumentStoreService.getMany).not.toHaveBeenCalled(); // Should not call get if no results
      expect(mockOllamaService.getCompletion).not.toHaveBeenCalled(); // Should not call getCompletion
      expect(result).toBe('No documents available in the knowledge base. Please add some documents first.');
    });
  });
});